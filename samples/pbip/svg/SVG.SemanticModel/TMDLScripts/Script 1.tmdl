createOrReplace

	function 'DaxLib.SVG.Compound.Violin' =
		(
			x: INT64,
			y: INT64,
			width: INT64,
			height: INT64,
			paddingX: DOUBLE,
			paddingY: DOUBLE,
			axisRef: ANYREF EXPR,
			measureRef: NUMERIC EXPR,
			samples: INT64,
			bandwidth: NUMERIC,
			color: STRING
		) =>
		
			// Apply padding to dimensions
			VAR _X = 			x + (width * (IF(ISBLANK(paddingX), 0, paddingX) / 2))
			VAR _Y = 			y + (height * (IF(ISBLANK(paddingY), 0, paddingY) / 2))
			VAR _Width = 		width * (1 - IF(ISBLANK(paddingX), 0, paddingX))
			VAR _Height = 		height * (1 - IF(ISBLANK(paddingY), 0, paddingY))

			// Check if Axis is numeric
			VAR axisSample = 	MAX( axisRef )
			VAR axisIsNumeric = ISNUMERIC( axisSample ) || ISDATETIME( axisSample )
			
			// For totals
			VAR _Data = 
				ADDCOLUMNS(
					FILTER(
						VALUES( axisRef ),
						NOT ISBLANK( measureRef )
					),
					"@AxisIndex", 	
						IF(
							axisIsNumeric,
							axisRef,
							RANK( DENSE, CALCULATETABLE( VALUES( axisRef ), ALLSELECTED() ) )
						),
					"@Value", measureRef
				)
	
			VAR _NumValues = 		COUNTROWS( _Data )
			VAR _Min = 				MINX( _Data, [@Value] )
			VAR _Max = 				MAXX( _Data, [@Value] )
			VAR _Range = 			_Max - _Min
			VAR _RangePerSample = 	_Range / samples

			// Calculate Kernel Density Estimation using Normal distribution
			VAR _KDE = 
				ADDCOLUMNS(
					GENERATESERIES( 0, samples + 1, 1 ),
					"@InputX", _Min + _RangePerSample * [Value],
					"@KDE", 
						( 1 / _NumValues ) * 
						SUMX(
							_Data, 
							NORM.DIST( 
								_Min + _RangePerSample * [Value], 
								[@Value], 
								bandwidth, 
								FALSE 
							) 
						)
				)

			VAR _MaxKDE = 		MAXX( _KDE, [@KDE] )

			// Map KDE values to SVG coordinates using normalize function
			VAR _Points = 
				ADDCOLUMNS(
					_KDE,
					"@X", DaxLib.SVG.Scale.Normalize( [@InputX], _Min, _Max, _X, _X + _Width),
					"@Y", DaxLib.SVG.Scale.Normalize( [@KDE], 0, _MaxKDE, _Y + _Height * 0.5, _Y )
				)

			// Create control points for smooth BÃ©zier curves
			VAR _PointsWithPrev = 
				NATURALLEFTOUTERJOIN(
					_Points,
					SELECTCOLUMNS(
						_Points,
						"Value", [Value] + 1,
						"@PrevX", [@X],
						"@PrevY", [@Y]
					)
				)

			VAR _WithControlPoints = 
				ADDCOLUMNS(
					_PointsWithPrev,
					"@CX", [@prevX] + ( ( [@x] - [@prevX] ) / 2 ),
					"@CY", [@y]
				)

		// Create the violin shape as a single closed path
		// Start at the center-left, go up the top curve, then down the bottom curve, and close
		VAR _FirstPoint = MINX( _Points, [@X] )
		VAR _LastPoint = MAXX( _Points, [@X] )
		VAR _CenterY = _Y + (_Height * 0.5)

		// Top half curve (from left to right)
		VAR _TopCurve = 
			CONCATENATEX(
				_WithControlPoints,
				IF(
					[Value] = 0,
					"M " & [@X] & " " & _CenterY,
					"S " & [@CX] & " " & [@CY] & ", " & [@X] & " " & [@Y]
				),
				" ",
				[Value],
				ASC
			)

		// Bottom half curve (from right to left, mirrored)
		VAR _BottomCurve = 
			CONCATENATEX(
				_WithControlPoints,
				VAR _MirroredY = _CenterY + (_CenterY - [@Y])
				VAR _MirroredCY = _CenterY + (_CenterY - [@CY])
				RETURN
					IF(
						[Value] = 0,
						"",
						"S " & [@CX] & " " & _MirroredCY & ", " & [@X] & " " & _MirroredY
					),
				" ",
				[Value],
				DESC
			)			// Create a single closed path for the violin shape
			VAR _ViolinPath = 
				_TopCurve & 
				" " & _BottomCurve & 
				" Z" // Close the path

			// Combined Elements
			VAR _CombinedElements = 
				DaxLib.SVG.Element.Paths(
					_ViolinPath, // d
					DaxLib.SVG.Attr.Shapes(
						color,          // fill
						0.5,          	// fillOpacity
						BLANK(),        // fillRule
						color,          // stroke
						1,              // strokeWidth
						BLANK(),        // strokeOpacity
						BLANK()         // opacity
					),
					BLANK()             // transforms
				)

			RETURN

				IF( NOT ISEMPTY( _Data ), _CombinedElements )
